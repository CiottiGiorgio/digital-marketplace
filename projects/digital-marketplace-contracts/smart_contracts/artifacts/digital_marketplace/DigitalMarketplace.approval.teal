#pragma version 10
#pragma typetrack false

// smart_contracts.digital_marketplace.contract.DigitalMarketplace.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 48 4
    bytecblock "deposited" "receipt_book" "sales" "" 0x0000
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@15
    pushbytess 0x3625e4eb 0x21f1ddff 0x13000a94 0xa6920066 0x09544810 0xd49ac60e 0xa18f1ffc 0x456e3975 0x1eabbb58 0xf8e0efaf // method "deposit(pay)void", method "withdraw(uint64)void", method "sponsor_asset(asset)void", method "open_sale(axfer,uint64)void", method "close_sale(asset)void", method "buy((address,uint64))void", method "bid((address,uint64),uint64)void", method "claim_unencumbered_bids()void", method "get_total_and_unencumbered_bids()(uint64,uint64)", method "accept_bid(uint64)void"
    txna ApplicationArgs 0
    match main_deposit_route@5 main_withdraw_route@6 main_sponsor_asset_route@7 main_open_sale_route@8 main_close_sale_route@9 main_buy_route@10 main_bid_route@11 main_claim_unencumbered_bids_route@12 main_get_total_and_unencumbered_bids_route@13 main_accept_bid_route@14

main_after_if_else@17:
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    intc_0 // 0
    return

main_accept_bid_route@14:
    // smart_contracts/digital_marketplace/contract.py:222
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/digital_marketplace/contract.py:222
    // @abimethod
    callsub accept_bid
    intc_1 // 1
    return

main_get_total_and_unencumbered_bids_route@13:
    // smart_contracts/digital_marketplace/contract.py:208
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_total_and_unencumbered_bids
    swap
    itob
    swap
    itob
    concat
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_claim_unencumbered_bids_route@12:
    // smart_contracts/digital_marketplace/contract.py:189
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub claim_unencumbered_bids
    intc_1 // 1
    return

main_bid_route@11:
    // smart_contracts/digital_marketplace/contract.py:154
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/digital_marketplace/contract.py:154
    // @abimethod
    callsub bid
    intc_1 // 1
    return

main_buy_route@10:
    // smart_contracts/digital_marketplace/contract.py:136
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/digital_marketplace/contract.py:136
    // @abimethod
    callsub buy
    intc_1 // 1
    return

main_close_sale_route@9:
    // smart_contracts/digital_marketplace/contract.py:121
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/digital_marketplace/contract.py:121
    // @abimethod
    callsub close_sale
    intc_1 // 1
    return

main_open_sale_route@8:
    // smart_contracts/digital_marketplace/contract.py:97
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    // smart_contracts/digital_marketplace/contract.py:97
    // @abimethod
    callsub open_sale
    intc_1 // 1
    return

main_sponsor_asset_route@7:
    // smart_contracts/digital_marketplace/contract.py:82
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/digital_marketplace/contract.py:82
    // @abimethod
    callsub sponsor_asset
    intc_1 // 1
    return

main_withdraw_route@6:
    // smart_contracts/digital_marketplace/contract.py:76
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/digital_marketplace/contract.py:76
    // @abimethod
    callsub withdraw
    intc_1 // 1
    return

main_deposit_route@5:
    // smart_contracts/digital_marketplace/contract.py:62
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/digital_marketplace/contract.py:62
    // @abimethod
    callsub deposit
    intc_1 // 1
    return

main_bare_routing@15:
    // smart_contracts/digital_marketplace/contract.py:55
    // class DigitalMarketplace(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@17
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.digital_marketplace.subroutines.find_bid_receipt(receipts: bytes, key: bytes) -> uint64, uint64:
find_bid_receipt:
    // smart_contracts/digital_marketplace/subroutines.py:6-9
    // @subroutine
    // def find_bid_receipt(
    //     receipts: ImmutableArray[BidReceipt], key: SaleKey
    // ) -> tuple[bool, UInt64]:
    proto 2 2
    // smart_contracts/digital_marketplace/subroutines.py:10
    // for i in urange(receipts.length):
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_0 // 0

find_bid_receipt_for_header@1:
    // smart_contracts/digital_marketplace/subroutines.py:10
    // for i in urange(receipts.length):
    frame_dig 1
    frame_dig 0
    <
    bz find_bid_receipt_after_for@6
    // smart_contracts/digital_marketplace/subroutines.py:11
    // if receipts[i].sale_key == key:
    frame_dig -2
    extract 2 0
    frame_dig 1
    intc_2 // 48
    *
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    extract 0 40 // on error: Index access is out of bounds
    frame_dig -1
    ==
    bz find_bid_receipt_after_if_else@4
    // smart_contracts/digital_marketplace/subroutines.py:12
    // return True, i
    intc_1 // 1
    frame_dig 1
    uncover 3
    uncover 3
    retsub

find_bid_receipt_after_if_else@4:
    // smart_contracts/digital_marketplace/subroutines.py:10
    // for i in urange(receipts.length):
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b find_bid_receipt_for_header@1

find_bid_receipt_after_for@6:
    // smart_contracts/digital_marketplace/subroutines.py:13
    // return False, UInt64(0)
    intc_0 // 0
    dup
    uncover 3
    uncover 3
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.deposit(payment: uint64) -> void:
deposit:
    // smart_contracts/digital_marketplace/contract.py:62-63
    // @abimethod
    // def deposit(self, payment: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:64
    // assert payment.sender == Txn.sender, err.DIFFERENT_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Different sender
    // smart_contracts/digital_marketplace/contract.py:66
    // payment.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/digital_marketplace/contract.py:65-67
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong receiver
    // smart_contracts/digital_marketplace/contract.py:69
    // mbr_baseline = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/digital_marketplace/contract.py:71
    // self.deposited.get(Txn.sender, default=UInt64(0)) + payment.amount
    bytec_0 // "deposited"
    txn Sender
    concat
    box_get
    swap
    btoi
    intc_0 // 0
    swap
    uncover 2
    select
    frame_dig -1
    gtxns Amount
    // smart_contracts/digital_marketplace/contract.py:70
    // self.deposited[Txn.sender] = (
    bytec_0 // "deposited"
    txn Sender
    concat
    // smart_contracts/digital_marketplace/contract.py:71
    // self.deposited.get(Txn.sender, default=UInt64(0)) + payment.amount
    cover 2
    +
    // smart_contracts/digital_marketplace/contract.py:70-72
    // self.deposited[Txn.sender] = (
    //     self.deposited.get(Txn.sender, default=UInt64(0)) + payment.amount
    // )
    itob
    box_put
    // smart_contracts/digital_marketplace/contract.py:73
    // mbr_diff = Global.current_application_address.min_balance - mbr_baseline
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    swap
    -
    // smart_contracts/digital_marketplace/contract.py:74
    // self.deposited[Txn.sender] -= mbr_diff
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    uncover 2
    -
    itob
    box_put
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.withdraw(amount: bytes) -> void:
withdraw:
    // smart_contracts/digital_marketplace/contract.py:76-77
    // @abimethod
    // def withdraw(self, amount: arc4.UInt64) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:78
    // self.deposited[Txn.sender] -= amount.native
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    frame_dig -1
    btoi
    swap
    dig 1
    -
    itob
    uncover 2
    swap
    box_put
    // smart_contracts/digital_marketplace/contract.py:80
    // itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    itxn_begin
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.sponsor_asset(asset: uint64) -> void:
sponsor_asset:
    // smart_contracts/digital_marketplace/contract.py:82-83
    // @abimethod
    // def sponsor_asset(self, asset: Asset) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:84
    // assert not Global.current_application_address.is_opted_in(
    global CurrentApplicationAddress
    // smart_contracts/digital_marketplace/contract.py:84-86
    // assert not Global.current_application_address.is_opted_in(
    //     asset
    // ), err.ALREADY_OPTED_IN
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    !
    assert // Already opted in
    // smart_contracts/digital_marketplace/contract.py:87
    // assert asset.clawback == Global.zero_address, err.CLAWBACK_ASA
    frame_dig -1
    asset_params_get AssetClawback
    assert // asset exists
    global ZeroAddress
    ==
    assert // Clawback ASA
    // smart_contracts/digital_marketplace/contract.py:89
    // self.deposited[Txn.sender] -= Global.asset_opt_in_min_balance
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    global AssetOptInMinBalance
    -
    itob
    box_put
    // smart_contracts/digital_marketplace/contract.py:91-95
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:93
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/digital_marketplace/contract.py:94
    // asset_amount=0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:91
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:91-95
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.open_sale(asset_deposit: uint64, cost: bytes) -> void:
open_sale:
    // smart_contracts/digital_marketplace/contract.py:97-100
    // @abimethod
    // def open_sale(
    //     self, asset_deposit: gtxn.AssetTransferTransaction, cost: arc4.UInt64
    // ) -> None:
    proto 2 0
    // smart_contracts/digital_marketplace/contract.py:101
    // assert asset_deposit.sender == Txn.sender, err.DIFFERENT_SENDER
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert // Different sender
    // smart_contracts/digital_marketplace/contract.py:103
    // asset_deposit.asset_receiver == Global.current_application_address
    frame_dig -2
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/digital_marketplace/contract.py:102-104
    // assert (
    //     asset_deposit.asset_receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong receiver
    // smart_contracts/digital_marketplace/contract.py:107
    // arc4.Address(Txn.sender), arc4.UInt64(asset_deposit.xfer_asset.id)
    txn Sender
    frame_dig -2
    gtxns XferAsset
    itob
    // smart_contracts/digital_marketplace/contract.py:106-108
    // sale_key = SaleKey(
    //     arc4.Address(Txn.sender), arc4.UInt64(asset_deposit.xfer_asset.id)
    // )
    concat
    // smart_contracts/digital_marketplace/contract.py:109
    // assert sale_key not in self.sales, err.SALE_ALREADY_EXISTS
    bytec_2 // "sales"
    swap
    concat
    dup
    box_len
    bury 1
    !
    assert // Sale already exists
    // smart_contracts/digital_marketplace/contract.py:111
    // mbr_baseline = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/digital_marketplace/contract.py:113
    // arc4.UInt64(asset_deposit.asset_amount),
    frame_dig -2
    gtxns AssetAmount
    itob
    // smart_contracts/digital_marketplace/contract.py:112-116
    // self.sales[sale_key] = Sale(
    //     arc4.UInt64(asset_deposit.asset_amount),
    //     cost,
    //     Bid(arc4.Address(), arc4.UInt64()),
    // )
    frame_dig -1
    concat
    // smart_contracts/digital_marketplace/contract.py:115
    // Bid(arc4.Address(), arc4.UInt64()),
    pushbytes base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    // smart_contracts/digital_marketplace/contract.py:112-116
    // self.sales[sale_key] = Sale(
    //     arc4.UInt64(asset_deposit.asset_amount),
    //     cost,
    //     Bid(arc4.Address(), arc4.UInt64()),
    // )
    concat
    uncover 2
    swap
    box_put
    // smart_contracts/digital_marketplace/contract.py:117
    // mbr_diff = Global.current_application_address.min_balance - mbr_baseline
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    swap
    -
    // smart_contracts/digital_marketplace/contract.py:119
    // self.deposited[Txn.sender] -= mbr_diff
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    uncover 2
    -
    itob
    box_put
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.close_sale(asset: uint64) -> void:
close_sale:
    // smart_contracts/digital_marketplace/contract.py:121-122
    // @abimethod
    // def close_sale(self, asset: Asset) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:123
    // sale_key = SaleKey(arc4.Address(Txn.sender), arc4.UInt64(asset.id))
    txn Sender
    frame_dig -1
    itob
    concat
    // smart_contracts/digital_marketplace/contract.py:125-129
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Txn.sender,
    //     asset_amount=self.sales[sale_key].amount.native,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:127
    // asset_receiver=Txn.sender,
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:128
    // asset_amount=self.sales[sale_key].amount.native,
    bytec_2 // "sales"
    uncover 2
    concat
    dup
    box_get
    assert // check self.sales entry exists
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    swap
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:125
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:125-129
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Txn.sender,
    //     asset_amount=self.sales[sale_key].amount.native,
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:131
    // mbr_baseline = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/digital_marketplace/contract.py:132
    // del self.sales[sale_key]
    swap
    box_del
    pop
    // smart_contracts/digital_marketplace/contract.py:133
    // mbr_diff = mbr_baseline - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    -
    // smart_contracts/digital_marketplace/contract.py:134
    // self.deposited[Txn.sender] += mbr_diff
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    uncover 2
    +
    itob
    box_put
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.buy(sale_key: bytes) -> void:
buy:
    // smart_contracts/digital_marketplace/contract.py:136-137
    // @abimethod
    // def buy(self, sale_key: SaleKey) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:138
    // assert Txn.sender != sale_key.owner.native, err.SELLER_CANT_BE_BUYER
    txn Sender
    frame_dig -1
    extract 0 32 // on error: Index access is out of bounds
    swap
    dig 1
    !=
    assert // Seller cannot be buyer
    // smart_contracts/digital_marketplace/contract.py:139
    // sale = self.sales[sale_key]
    bytec_2 // "sales"
    frame_dig -1
    concat
    dup
    box_get
    assert // check self.sales entry exists
    // smart_contracts/digital_marketplace/contract.py:141-145
    // itxn.AssetTransfer(
    //     xfer_asset=sale_key.asset.native,
    //     asset_receiver=Txn.sender,
    //     asset_amount=sale.amount.native,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:142
    // xfer_asset=sale_key.asset.native,
    frame_dig -1
    pushint 32 // 32
    extract_uint64
    // smart_contracts/digital_marketplace/contract.py:143
    // asset_receiver=Txn.sender,
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:144
    // asset_amount=sale.amount.native,
    dig 2
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:141
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:141-145
    // itxn.AssetTransfer(
    //     xfer_asset=sale_key.asset.native,
    //     asset_receiver=Txn.sender,
    //     asset_amount=sale.amount.native,
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:147
    // mbr_baseline = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/digital_marketplace/contract.py:148
    // del self.sales[sale_key]
    uncover 2
    box_del
    pop
    // smart_contracts/digital_marketplace/contract.py:149
    // mbr_diff = mbr_baseline - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    -
    // smart_contracts/digital_marketplace/contract.py:151
    // self.deposited[Txn.sender] -= sale.cost.native
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    uncover 3
    pushint 8 // 8
    extract_uint64
    swap
    dig 1
    -
    itob
    uncover 2
    swap
    box_put
    // smart_contracts/digital_marketplace/contract.py:152
    // self.deposited[sale_key.owner.native] += sale.cost.native + mbr_diff
    bytec_0 // "deposited"
    uncover 3
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    uncover 2
    uncover 3
    +
    +
    itob
    box_put
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.bid(sale_key: bytes, new_bid_amount: bytes) -> void:
bid:
    // smart_contracts/digital_marketplace/contract.py:154-155
    // @abimethod
    // def bid(self, sale_key: SaleKey, new_bid_amount: arc4.UInt64) -> None:
    proto 2 0
    intc_0 // 0
    dup
    bytec_3 // ""
    dup
    // smart_contracts/digital_marketplace/contract.py:156
    // new_bid = Bid(bidder=arc4.Address(Txn.sender), amount=new_bid_amount)
    txn Sender
    frame_dig -1
    concat
    // smart_contracts/digital_marketplace/contract.py:158
    // assert Txn.sender != sale_key.owner, err.SELLER_CANT_BE_BIDDER
    frame_dig -2
    extract 0 32 // on error: Index access is out of bounds
    txn Sender
    !=
    assert // Seller cannot be bidder
    // smart_contracts/digital_marketplace/contract.py:160
    // sale = self.sales[sale_key]
    bytec_2 // "sales"
    frame_dig -2
    concat
    dup
    box_get
    swap
    dup
    uncover 2
    assert // check self.sales entry exists
    // smart_contracts/digital_marketplace/contract.py:161
    // if sale.bid.bidder:
    extract 16 40 // on error: Index access is out of bounds
    dup
    extract 0 32 // on error: Index access is out of bounds
    global ZeroAddress
    !=
    bz bid_after_if_else@2
    // smart_contracts/digital_marketplace/contract.py:162
    // assert sale.bid.amount.native < new_bid_amount.native, err.WORSE_BID
    frame_dig 7
    pushint 32 // 32
    extract_uint64
    frame_dig -1
    btoi
    <
    assert // Worse bid

bid_after_if_else@2:
    // smart_contracts/digital_marketplace/contract.py:164
    // self.sales[sale_key] = sale._replace(bid=new_bid)
    frame_dig 6
    dup
    extract 0 8 // on error: Index access is out of bounds
    swap
    extract 8 8 // on error: Index access is out of bounds
    concat
    frame_dig 4
    concat
    frame_dig 5
    swap
    box_put
    // smart_contracts/digital_marketplace/contract.py:166
    // mbr_baseline = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    swap
    frame_bury 3
    assert // account funded
    // smart_contracts/digital_marketplace/contract.py:167
    // new_bid_receipt = BidReceipt(sale_key, new_bid_amount)
    frame_dig -2
    frame_dig -1
    concat
    frame_bury 0
    // smart_contracts/digital_marketplace/contract.py:168
    // receipt_book, exists = self.receipt_book.maybe(Txn.sender)
    bytec_1 // "receipt_book"
    txn Sender
    concat
    box_get
    swap
    frame_bury 1
    // smart_contracts/digital_marketplace/contract.py:169
    // if exists:
    bz bid_else_body@7
    // smart_contracts/digital_marketplace/contract.py:170
    // found, index = find_bid_receipt(receipt_book, sale_key)
    frame_dig 1
    frame_dig -2
    callsub find_bid_receipt
    frame_bury 2
    // smart_contracts/digital_marketplace/contract.py:171
    // if found:
    bz bid_else_body@5
    // smart_contracts/digital_marketplace/contract.py:172
    // self.deposited[Txn.sender] += receipt_book[index].amount.native
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    frame_dig 1
    dup
    cover 2
    extract 2 0
    frame_dig 2
    dup
    cover 4
    intc_2 // 48
    *
    swap
    dig 1
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    pushint 40 // 40
    extract_uint64
    uncover 2
    +
    itob
    uncover 4
    swap
    box_put
    // smart_contracts/digital_marketplace/contract.py:173-175
    // self.receipt_book[Txn.sender] = receipt_book.replace(
    //     index, new_bid_receipt
    // )
    dig 1
    intc_0 // 0
    extract_uint16
    uncover 3
    >
    assert // Index access is out of bounds
    pushint 2 // 2
    +
    frame_dig 0
    replace3
    // smart_contracts/digital_marketplace/contract.py:173
    // self.receipt_book[Txn.sender] = receipt_book.replace(
    bytec_1 // "receipt_book"
    txn Sender
    concat
    // smart_contracts/digital_marketplace/contract.py:173-175
    // self.receipt_book[Txn.sender] = receipt_book.replace(
    //     index, new_bid_receipt
    // )
    dup
    box_del
    pop
    swap
    box_put

bid_after_if_else@8:
    // smart_contracts/digital_marketplace/contract.py:180
    // mbr_diff = Global.current_application_address.min_balance - mbr_baseline
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    frame_dig 3
    -
    // smart_contracts/digital_marketplace/contract.py:182
    // self.deposited[Txn.sender] -= new_bid_amount.native + mbr_diff
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    frame_dig -1
    btoi
    uncover 3
    +
    -
    itob
    box_put
    retsub

bid_else_body@5:
    // smart_contracts/digital_marketplace/contract.py:177
    // self.receipt_book[Txn.sender] = receipt_book.append(new_bid_receipt)
    frame_dig 1
    extract 2 0
    frame_dig 0
    concat
    dup
    len
    intc_2 // 48
    /
    itob
    extract 6 2
    swap
    concat
    bytec_1 // "receipt_book"
    txn Sender
    concat
    dup
    box_del
    pop
    swap
    box_put
    b bid_after_if_else@8

bid_else_body@7:
    // smart_contracts/digital_marketplace/contract.py:179
    // self.receipt_book[Txn.sender] = ImmutableArray(new_bid_receipt)
    pushbytes 0x0001
    frame_dig 0
    concat
    bytec_1 // "receipt_book"
    txn Sender
    concat
    dup
    box_del
    pop
    swap
    box_put
    b bid_after_if_else@8


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.is_encumbered(bid: bytes) -> uint64:
is_encumbered:
    // smart_contracts/digital_marketplace/contract.py:184-185
    // @subroutine
    // def is_encumbered(self, bid: BidReceipt) -> bool:
    proto 1 1
    intc_0 // 0
    // smart_contracts/digital_marketplace/contract.py:186
    // sale, exists = self.sales.maybe(bid.sale_key)
    frame_dig -1
    extract 0 40 // on error: Index access is out of bounds
    bytec_2 // "sales"
    swap
    concat
    box_get
    // smart_contracts/digital_marketplace/contract.py:187
    // return exists and bool(sale.bid.bidder) and sale.bid.bidder == Txn.sender
    bz is_encumbered_bool_false@4
    frame_dig 1
    extract 16 40 // on error: Index access is out of bounds
    extract 0 32 // on error: Index access is out of bounds
    dup
    frame_bury 0
    global ZeroAddress
    !=
    bz is_encumbered_bool_false@4
    frame_dig 0
    txn Sender
    ==
    bz is_encumbered_bool_false@4
    intc_1 // 1

is_encumbered_bool_merge@5:
    // smart_contracts/digital_marketplace/contract.py:187
    // return exists and bool(sale.bid.bidder) and sale.bid.bidder == Txn.sender
    frame_bury 0
    retsub

is_encumbered_bool_false@4:
    intc_0 // 0
    b is_encumbered_bool_merge@5


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.claim_unencumbered_bids() -> void:
claim_unencumbered_bids:
    // smart_contracts/digital_marketplace/contract.py:189-190
    // @abimethod
    // def claim_unencumbered_bids(self) -> None:
    proto 0 0
    bytec_3 // ""
    // smart_contracts/digital_marketplace/contract.py:191
    // encumbered_receipts = ImmutableArray[BidReceipt]()
    bytec 4 // 0x0000
    // smart_contracts/digital_marketplace/contract.py:193
    // for receipt in self.receipt_book[Txn.sender]:
    bytec_1 // "receipt_book"
    txn Sender
    concat
    box_get
    swap
    dup
    uncover 2
    assert // check self.receipt_book entry exists
    intc_0 // 0
    extract_uint16
    intc_0 // 0

claim_unencumbered_bids_for_header@1:
    // smart_contracts/digital_marketplace/contract.py:193
    // for receipt in self.receipt_book[Txn.sender]:
    frame_dig 4
    frame_dig 3
    <
    bz claim_unencumbered_bids_after_for@7
    frame_dig 2
    extract 2 0
    frame_dig 4
    intc_2 // 48
    *
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    dup
    // smart_contracts/digital_marketplace/contract.py:194
    // if self.is_encumbered(receipt):
    callsub is_encumbered
    bz claim_unencumbered_bids_else_body@4
    // smart_contracts/digital_marketplace/contract.py:195
    // encumbered_receipts = encumbered_receipts.append(receipt)
    frame_dig 1
    extract 2 0
    swap
    concat
    dup
    len
    intc_2 // 48
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1

claim_unencumbered_bids_after_if_else@5:
    frame_dig 4
    intc_1 // 1
    +
    frame_bury 4
    b claim_unencumbered_bids_for_header@1

claim_unencumbered_bids_else_body@4:
    // smart_contracts/digital_marketplace/contract.py:197
    // self.deposited[Txn.sender] += receipt.amount.native
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    uncover 2
    pushint 40 // 40
    extract_uint64
    +
    itob
    box_put
    b claim_unencumbered_bids_after_if_else@5

claim_unencumbered_bids_after_for@7:
    // smart_contracts/digital_marketplace/contract.py:199
    // mbr_baseline = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    swap
    frame_bury 0
    assert // account funded
    // smart_contracts/digital_marketplace/contract.py:200
    // if encumbered_receipts:
    frame_dig 1
    intc_0 // 0
    extract_uint16
    bz claim_unencumbered_bids_else_body@9
    // smart_contracts/digital_marketplace/contract.py:201
    // self.receipt_book[Txn.sender] = encumbered_receipts
    bytec_1 // "receipt_book"
    txn Sender
    concat
    dup
    box_del
    pop
    frame_dig 1
    box_put

claim_unencumbered_bids_after_if_else@10:
    // smart_contracts/digital_marketplace/contract.py:204
    // mbr_diff = mbr_baseline - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    frame_dig 0
    swap
    -
    // smart_contracts/digital_marketplace/contract.py:206
    // self.deposited[Txn.sender] += mbr_diff
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    uncover 2
    +
    itob
    box_put
    retsub

claim_unencumbered_bids_else_body@9:
    // smart_contracts/digital_marketplace/contract.py:203
    // del self.receipt_book[Txn.sender]
    bytec_1 // "receipt_book"
    txn Sender
    concat
    box_del
    pop
    b claim_unencumbered_bids_after_if_else@10


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.get_total_and_unencumbered_bids() -> uint64, uint64:
get_total_and_unencumbered_bids:
    // smart_contracts/digital_marketplace/contract.py:208-209
    // @abimethod(readonly=True)
    // def get_total_and_unencumbered_bids(self) -> UnencumberedBidsReceipt:
    proto 0 2
    bytec_3 // ""
    dupn 2
    // smart_contracts/digital_marketplace/contract.py:210
    // total_bids = UInt64(0)
    intc_0 // 0
    // smart_contracts/digital_marketplace/contract.py:210-211
    // total_bids = UInt64(0)
    // unencumbered_bids = UInt64(0)
    dupn 3
    // smart_contracts/digital_marketplace/contract.py:213
    // receipt_book, exists = self.receipt_book.maybe(Txn.sender)
    bytec_1 // "receipt_book"
    txn Sender
    concat
    box_get
    swap
    cover 3
    swap
    cover 2
    // smart_contracts/digital_marketplace/contract.py:214
    // if exists:
    bz get_total_and_unencumbered_bids_after_if_else@8
    // smart_contracts/digital_marketplace/contract.py:215
    // for receipt in receipt_book:
    frame_dig 5
    intc_0 // 0
    extract_uint16
    frame_bury 0
    intc_0 // 0
    frame_bury 1

get_total_and_unencumbered_bids_for_header@2:
    // smart_contracts/digital_marketplace/contract.py:215
    // for receipt in receipt_book:
    frame_dig 1
    frame_dig 0
    <
    bz get_total_and_unencumbered_bids_after_for@7
    frame_dig 5
    extract 2 0
    frame_dig 1
    intc_2 // 48
    *
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    // smart_contracts/digital_marketplace/contract.py:216
    // total_bids += receipt.amount.native
    dup
    pushint 40 // 40
    extract_uint64
    dup
    frame_bury 2
    frame_dig 3
    +
    frame_bury 3
    // smart_contracts/digital_marketplace/contract.py:217
    // if not self.is_encumbered(receipt):
    callsub is_encumbered
    frame_dig 4
    frame_bury 6
    bnz get_total_and_unencumbered_bids_after_if_else@5
    // smart_contracts/digital_marketplace/contract.py:218
    // unencumbered_bids += receipt.amount.native
    frame_dig 4
    frame_dig 2
    +
    frame_bury 6

get_total_and_unencumbered_bids_after_if_else@5:
    frame_dig 6
    frame_bury 4
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b get_total_and_unencumbered_bids_for_header@2

get_total_and_unencumbered_bids_after_for@7:
    frame_dig 4
    frame_bury 6
    frame_dig 3
    frame_bury 7

get_total_and_unencumbered_bids_after_if_else@8:
    frame_dig 7
    frame_dig 6
    // smart_contracts/digital_marketplace/contract.py:220
    // return UnencumberedBidsReceipt(total_bids, unencumbered_bids)
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.accept_bid(asset: bytes) -> void:
accept_bid:
    // smart_contracts/digital_marketplace/contract.py:222-223
    // @abimethod
    // def accept_bid(self, asset: arc4.UInt64) -> None:
    proto 1 0
    intc_0 // 0
    dup
    bytec_3 // ""
    // smart_contracts/digital_marketplace/contract.py:224
    // sale_key = SaleKey(owner=arc4.Address(Txn.sender), asset=asset)
    txn Sender
    frame_dig -1
    concat
    // smart_contracts/digital_marketplace/contract.py:225
    // sale = self.sales[sale_key]
    bytec_2 // "sales"
    dig 1
    concat
    dup
    box_get
    assert // check self.sales entry exists
    // smart_contracts/digital_marketplace/contract.py:226
    // current_best_bid = sale.bid
    dup
    extract 16 40 // on error: Index access is out of bounds
    // smart_contracts/digital_marketplace/contract.py:227
    // current_best_bidder = current_best_bid.bidder.native
    dup
    extract 0 32 // on error: Index access is out of bounds
    dup
    cover 4
    cover 5
    // smart_contracts/digital_marketplace/contract.py:229
    // seller_mbr_baseline = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/digital_marketplace/contract.py:230
    // del self.sales[sale_key]
    uncover 3
    box_del
    pop
    // smart_contracts/digital_marketplace/contract.py:232
    // seller_mbr_baseline - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    -
    // smart_contracts/digital_marketplace/contract.py:235
    // self.deposited[Txn.sender] += current_best_bid.amount.native + seller_mbr_diff
    bytec_0 // "deposited"
    txn Sender
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    uncover 3
    pushint 32 // 32
    extract_uint64
    uncover 3
    +
    +
    itob
    box_put
    // smart_contracts/digital_marketplace/contract.py:236-240
    // itxn.AssetTransfer(
    //     xfer_asset=asset.native,
    //     asset_receiver=current_best_bidder,
    //     asset_amount=sale.amount.native,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:237
    // xfer_asset=asset.native,
    frame_dig -1
    btoi
    // smart_contracts/digital_marketplace/contract.py:239
    // asset_amount=sale.amount.native,
    swap
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    dig 1
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:236
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:236-240
    // itxn.AssetTransfer(
    //     xfer_asset=asset.native,
    //     asset_receiver=current_best_bidder,
    //     asset_amount=sale.amount.native,
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:242
    // receipt_book = self.receipt_book[current_best_bidder]
    bytec_1 // "receipt_book"
    swap
    concat
    dup
    cover 2
    box_get
    swap
    dup
    cover 2
    cover 3
    assert // check self.receipt_book entry exists
    // smart_contracts/digital_marketplace/contract.py:243
    // found, index = find_bid_receipt(receipt_book, sale_key)
    dup
    uncover 2
    callsub find_bid_receipt
    cover 2
    // smart_contracts/digital_marketplace/contract.py:244
    // assert found
    assert
    // smart_contracts/digital_marketplace/contract.py:246
    // encumbered_receipts = ImmutableArray[BidReceipt]()
    bytec 4 // 0x0000
    swap
    // smart_contracts/digital_marketplace/contract.py:247
    // for receipt in receipt_book:
    intc_0 // 0
    extract_uint16
    intc_0 // 0

accept_bid_for_header@2:
    // smart_contracts/digital_marketplace/contract.py:247
    // for receipt in receipt_book:
    frame_dig 9
    frame_dig 8
    <
    bz accept_bid_after_for@7
    frame_dig 5
    extract 2 0
    frame_dig 9
    intc_2 // 48
    *
    dig 1
    swap
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    dup
    cover 2
    frame_bury 1
    // smart_contracts/digital_marketplace/contract.py:248
    // if receipt != receipt_book[index]:
    frame_dig 6
    intc_2 // 48
    *
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    !=
    frame_dig 7
    frame_bury 0
    bz accept_bid_after_if_else@5
    // smart_contracts/digital_marketplace/contract.py:249
    // encumbered_receipts = encumbered_receipts.append(receipt)
    frame_dig 7
    extract 2 0
    frame_dig 1
    concat
    dup
    len
    intc_2 // 48
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 0

accept_bid_after_if_else@5:
    frame_dig 0
    frame_bury 7
    frame_dig 9
    intc_1 // 1
    +
    frame_bury 9
    b accept_bid_for_header@2

accept_bid_after_for@7:
    // smart_contracts/digital_marketplace/contract.py:251
    // bidder_mbr_baseline = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    swap
    frame_bury 2
    assert // account funded
    // smart_contracts/digital_marketplace/contract.py:252
    // if encumbered_receipts:
    frame_dig 7
    intc_0 // 0
    extract_uint16
    bz accept_bid_else_body@9
    // smart_contracts/digital_marketplace/contract.py:253
    // self.receipt_book[current_best_bidder] = encumbered_receipts
    frame_dig 4
    dup
    box_del
    pop
    frame_dig 7
    box_put

accept_bid_after_if_else@10:
    // smart_contracts/digital_marketplace/contract.py:257
    // bidder_mbr_baseline - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/digital_marketplace/contract.py:256-258
    // bidder_mbr_diff = (
    //     bidder_mbr_baseline - Global.current_application_address.min_balance
    // )
    frame_dig 2
    swap
    // smart_contracts/digital_marketplace/contract.py:257
    // bidder_mbr_baseline - Global.current_application_address.min_balance
    -
    // smart_contracts/digital_marketplace/contract.py:260
    // self.deposited[current_best_bidder] += bidder_mbr_diff
    bytec_0 // "deposited"
    frame_dig 3
    concat
    dup
    box_get
    swap
    btoi
    swap
    assert // check self.deposited entry exists
    uncover 2
    +
    itob
    box_put
    retsub

accept_bid_else_body@9:
    // smart_contracts/digital_marketplace/contract.py:255
    // del self.receipt_book[current_best_bidder]
    frame_dig 4
    box_del
    pop
    b accept_bid_after_if_else@10
