#pragma version 10
#pragma typetrack false

// smart_contracts.digital_marketplace.contract.DigitalMarketplace.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 4 3 44500
    bytecblock "deposited" "sales"
    // smart_contracts/digital_marketplace/contract.py:40
    // class DigitalMarketplace(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@11
    pushbytess 0x3625e4eb 0x21f1ddff 0x13000a94 0xa6920066 0x09544810 0x22174a73 // method "deposit(pay)void", method "withdraw(uint64)void", method "sponsor_asset(asset)void", method "open_sale(axfer,uint64)void", method "close_sale(asset)void", method "buy((address,uint64),pay)void"
    txna ApplicationArgs 0
    match main_deposit_route@5 main_withdraw_route@6 main_sponsor_asset_route@7 main_open_sale_route@8 main_close_sale_route@9 main_buy_route@10

main_after_if_else@13:
    // smart_contracts/digital_marketplace/contract.py:40
    // class DigitalMarketplace(ARC4Contract):
    intc_0 // 0
    return

main_buy_route@10:
    // smart_contracts/digital_marketplace/contract.py:133
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:40
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/digital_marketplace/contract.py:133
    // @abimethod
    callsub buy
    intc_1 // 1
    return

main_close_sale_route@9:
    // smart_contracts/digital_marketplace/contract.py:117
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    intc_1 // 1
    txn OnCompletion
    shl
    intc_3 // 3
    &
    assert // OnCompletion is not one of NoOp, OptIn
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:40
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/digital_marketplace/contract.py:117
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    callsub close_sale
    intc_1 // 1
    return

main_open_sale_route@8:
    // smart_contracts/digital_marketplace/contract.py:100
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:40
    // class DigitalMarketplace(ARC4Contract):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    // smart_contracts/digital_marketplace/contract.py:100
    // @abimethod
    callsub open_sale
    intc_1 // 1
    return

main_sponsor_asset_route@7:
    // smart_contracts/digital_marketplace/contract.py:86
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:40
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/digital_marketplace/contract.py:86
    // @abimethod
    callsub sponsor_asset
    intc_1 // 1
    return

main_withdraw_route@6:
    // smart_contracts/digital_marketplace/contract.py:79
    // @abimethod(allow_actions=["NoOp", "CloseOut"])
    intc_1 // 1
    txn OnCompletion
    shl
    pushint 5 // 5
    &
    assert // OnCompletion is not one of NoOp, CloseOut
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:40
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/digital_marketplace/contract.py:79
    // @abimethod(allow_actions=["NoOp", "CloseOut"])
    callsub withdraw
    intc_1 // 1
    return

main_deposit_route@5:
    // smart_contracts/digital_marketplace/contract.py:68
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    intc_1 // 1
    txn OnCompletion
    shl
    intc_3 // 3
    &
    assert // OnCompletion is not one of NoOp, OptIn
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:40
    // class DigitalMarketplace(ARC4Contract):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/digital_marketplace/contract.py:68
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    callsub deposit
    intc_1 // 1
    return

main_bare_routing@11:
    // smart_contracts/digital_marketplace/contract.py:40
    // class DigitalMarketplace(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@13
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.deposit(payment: uint64) -> void:
deposit:
    // smart_contracts/digital_marketplace/contract.py:68-69
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    // def deposit(self, payment: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:70
    // assert payment.sender == Txn.sender, err.DIFFERENT_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Different sender
    // smart_contracts/digital_marketplace/contract.py:72
    // payment.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/digital_marketplace/contract.py:71-73
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong receiver
    // smart_contracts/digital_marketplace/contract.py:76
    // self.deposited.get(Txn.sender, default=UInt64(0)) + payment.amount
    txn Sender
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    frame_dig -1
    gtxns Amount
    // smart_contracts/digital_marketplace/contract.py:75
    // self.deposited[Txn.sender] = (
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:76
    // self.deposited.get(Txn.sender, default=UInt64(0)) + payment.amount
    cover 2
    +
    // smart_contracts/digital_marketplace/contract.py:75
    // self.deposited[Txn.sender] = (
    bytec_0 // "deposited"
    // smart_contracts/digital_marketplace/contract.py:75-77
    // self.deposited[Txn.sender] = (
    //     self.deposited.get(Txn.sender, default=UInt64(0)) + payment.amount
    // )
    swap
    app_local_put
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.withdraw(amount: bytes) -> void:
withdraw:
    // smart_contracts/digital_marketplace/contract.py:79-80
    // @abimethod(allow_actions=["NoOp", "CloseOut"])
    // def withdraw(self, amount: arc4.UInt64) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:81-82
    // # FIXME: We want to prevent closing out if there's still balance
    // self.deposited[Txn.sender] -= amount.native
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    frame_dig -1
    btoi
    swap
    dig 1
    -
    uncover 2
    bytec_0 // "deposited"
    uncover 2
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:84
    // itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    itxn_begin
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.sponsor_asset(asset: uint64) -> void:
sponsor_asset:
    // smart_contracts/digital_marketplace/contract.py:86-87
    // @abimethod
    // def sponsor_asset(self, asset: Asset) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:88
    // assert not Global.current_application_address.is_opted_in(
    global CurrentApplicationAddress
    // smart_contracts/digital_marketplace/contract.py:88-90
    // assert not Global.current_application_address.is_opted_in(
    //     asset
    // ), err.ALREADY_OPTED_IN
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    !
    assert // Already opted in
    // smart_contracts/digital_marketplace/contract.py:92
    // self.deposited[Txn.sender] -= Global.asset_opt_in_min_balance
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    global AssetOptInMinBalance
    -
    bytec_0 // "deposited"
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:94-98
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:96
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/digital_marketplace/contract.py:97
    // asset_amount=0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:94
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:94-98
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.open_sale(asset_deposit: uint64, cost: bytes) -> void:
open_sale:
    // smart_contracts/digital_marketplace/contract.py:100-103
    // @abimethod
    // def open_sale(
    //     self, asset_deposit: gtxn.AssetTransferTransaction, cost: arc4.UInt64
    // ) -> None:
    proto 2 0
    // smart_contracts/digital_marketplace/contract.py:104
    // assert asset_deposit.sender == Txn.sender, err.DIFFERENT_SENDER
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert // Different sender
    // smart_contracts/digital_marketplace/contract.py:106
    // asset_deposit.asset_receiver == Global.current_application_address
    frame_dig -2
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/digital_marketplace/contract.py:105-107
    // assert (
    //     asset_deposit.asset_receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong receiver
    // smart_contracts/digital_marketplace/contract.py:109
    // self.deposited[Txn.sender] -= self.sales_box_mbr()
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    // smart_contracts/digital_marketplace/contract.py:48-65
    // # fmt: off
    // return 2_500 + 400 * (
    //     # Domain separator
    //     self.sales.key_prefix.length +
    //     # SaleKey
    //     32 + 8 +
    //     # Sale
    //     # Since the Sale type contains one dynamic type,
    //     #  it's got a 2 byte prefix pointing to that dynamic type
    //     2 +
    //     # amount & cost fields
    //     8 + 8 +
    //     # bid field is a dynamic array and so it has got a length prefix plus
    //     #  one Bid type at most
    //     2 +
    //     # One optional Bid type
    //     (32 + 8)
    // )
    intc 4 // 44500
    // smart_contracts/digital_marketplace/contract.py:109
    // self.deposited[Txn.sender] -= self.sales_box_mbr()
    -
    bytec_0 // "deposited"
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:114
    // arc4.UInt64(asset_deposit.asset_amount), cost, arc4.DynamicArray[Bid]()
    frame_dig -2
    gtxns AssetAmount
    itob
    // smart_contracts/digital_marketplace/contract.py:113-115
    // ] = Sale(
    //     arc4.UInt64(asset_deposit.asset_amount), cost, arc4.DynamicArray[Bid]()
    // )
    frame_dig -1
    concat
    pushbytes 0x0012
    concat
    // smart_contracts/digital_marketplace/contract.py:114
    // arc4.UInt64(asset_deposit.asset_amount), cost, arc4.DynamicArray[Bid]()
    pushbytes 0x0000
    // smart_contracts/digital_marketplace/contract.py:113-115
    // ] = Sale(
    //     arc4.UInt64(asset_deposit.asset_amount), cost, arc4.DynamicArray[Bid]()
    // )
    concat
    // smart_contracts/digital_marketplace/contract.py:112
    // SaleKey(arc4.Address(Txn.sender), arc4.UInt64(asset_deposit.xfer_asset.id))
    txn Sender
    frame_dig -2
    gtxns XferAsset
    itob
    concat
    // smart_contracts/digital_marketplace/contract.py:111
    // self.sales[
    bytec_1 // "sales"
    // smart_contracts/digital_marketplace/contract.py:111-113
    // self.sales[
    //     SaleKey(arc4.Address(Txn.sender), arc4.UInt64(asset_deposit.xfer_asset.id))
    // ] = Sale(
    swap
    concat
    // smart_contracts/digital_marketplace/contract.py:111-115
    // self.sales[
    //     SaleKey(arc4.Address(Txn.sender), arc4.UInt64(asset_deposit.xfer_asset.id))
    // ] = Sale(
    //     arc4.UInt64(asset_deposit.asset_amount), cost, arc4.DynamicArray[Bid]()
    // )
    dup
    box_del
    pop
    swap
    box_put
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.close_sale(asset: uint64) -> void:
close_sale:
    // smart_contracts/digital_marketplace/contract.py:117-118
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    // def close_sale(self, asset: Asset) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:119
    // sale_key = SaleKey(arc4.Address(Txn.sender), arc4.UInt64(asset.id))
    txn Sender
    frame_dig -1
    itob
    concat
    // smart_contracts/digital_marketplace/contract.py:121-125
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Txn.sender,
    //     asset_amount=self.sales[sale_key].amount.native,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:123
    // asset_receiver=Txn.sender,
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:124
    // asset_amount=self.sales[sale_key].amount.native,
    bytec_1 // "sales"
    uncover 2
    concat
    dup
    box_get
    assert // check self.sales entry exists
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    swap
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:121
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:121-125
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Txn.sender,
    //     asset_amount=self.sales[sale_key].amount.native,
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:128
    // self.deposited.get(Txn.sender, default=UInt64(0)) + self.sales_box_mbr()
    txn Sender
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/digital_marketplace/contract.py:127
    // self.deposited[Txn.sender] = (
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:128
    // self.deposited.get(Txn.sender, default=UInt64(0)) + self.sales_box_mbr()
    swap
    // smart_contracts/digital_marketplace/contract.py:48-65
    // # fmt: off
    // return 2_500 + 400 * (
    //     # Domain separator
    //     self.sales.key_prefix.length +
    //     # SaleKey
    //     32 + 8 +
    //     # Sale
    //     # Since the Sale type contains one dynamic type,
    //     #  it's got a 2 byte prefix pointing to that dynamic type
    //     2 +
    //     # amount & cost fields
    //     8 + 8 +
    //     # bid field is a dynamic array and so it has got a length prefix plus
    //     #  one Bid type at most
    //     2 +
    //     # One optional Bid type
    //     (32 + 8)
    // )
    intc 4 // 44500
    // smart_contracts/digital_marketplace/contract.py:128
    // self.deposited.get(Txn.sender, default=UInt64(0)) + self.sales_box_mbr()
    +
    // smart_contracts/digital_marketplace/contract.py:127
    // self.deposited[Txn.sender] = (
    bytec_0 // "deposited"
    // smart_contracts/digital_marketplace/contract.py:127-129
    // self.deposited[Txn.sender] = (
    //     self.deposited.get(Txn.sender, default=UInt64(0)) + self.sales_box_mbr()
    // )
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:131
    // del self.sales[sale_key]
    box_del
    pop
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.buy(sale_key: bytes, payment: uint64) -> void:
buy:
    // smart_contracts/digital_marketplace/contract.py:133-134
    // @abimethod
    // def buy(self, sale_key: SaleKey, payment: gtxn.PaymentTransaction) -> None:
    proto 2 0
    // smart_contracts/digital_marketplace/contract.py:135
    // assert payment.sender == Txn.sender, err.DIFFERENT_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Different sender
    // smart_contracts/digital_marketplace/contract.py:137
    // payment.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/digital_marketplace/contract.py:136-138
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong receiver
    // smart_contracts/digital_marketplace/contract.py:139
    // assert payment.amount == self.sales[sale_key].cost
    bytec_1 // "sales"
    frame_dig -2
    concat
    dup
    box_get
    assert // check self.sales entry exists
    extract 8 8 // on error: Index access is out of bounds
    frame_dig -1
    gtxns Amount
    dup
    itob
    uncover 2
    b==
    assert
    // smart_contracts/digital_marketplace/contract.py:141
    // self.deposited[sale_key.owner.native] += payment.amount
    frame_dig -2
    extract 0 32 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    uncover 2
    +
    bytec_0 // "deposited"
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:143-147
    // itxn.AssetTransfer(
    //     xfer_asset=sale_key.asset.native,
    //     asset_receiver=Txn.sender,
    //     asset_amount=self.sales[sale_key].amount.native,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:144
    // xfer_asset=sale_key.asset.native,
    frame_dig -2
    pushint 32 // 32
    extract_uint64
    // smart_contracts/digital_marketplace/contract.py:145
    // asset_receiver=Txn.sender,
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:146
    // asset_amount=self.sales[sale_key].amount.native,
    dig 2
    box_get
    assert // check self.sales entry exists
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:143
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:143-147
    // itxn.AssetTransfer(
    //     xfer_asset=sale_key.asset.native,
    //     asset_receiver=Txn.sender,
    //     asset_amount=self.sales[sale_key].amount.native,
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:149
    // del self.sales[sale_key]
    box_del
    pop
    retsub
