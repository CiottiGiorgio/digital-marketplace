#pragma version 10
#pragma typetrack false

// smart_contracts.digital_marketplace.contract.DigitalMarketplace.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 48 16 13135300
    bytecblock "deposited" "placed_bids" "sales" 0x0000
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@14
    pushbytess 0x3625e4eb 0x21f1ddff 0x13000a94 0xa6920066 0x09544810 0xd49ac60e 0xa18f1ffc 0x456e3975 0xf8e0efaf // method "deposit(pay)void", method "withdraw(uint64)void", method "sponsor_asset(asset)void", method "open_sale(axfer,uint64)void", method "close_sale(asset)void", method "buy((address,uint64))void", method "bid((address,uint64),uint64)void", method "claim_unencumbered_bids()void", method "accept_bid(uint64)void"
    txna ApplicationArgs 0
    match main_deposit_route@5 main_withdraw_route@6 main_sponsor_asset_route@7 main_open_sale_route@8 main_close_sale_route@9 main_buy_route@10 main_bid_route@11 main_claim_unencumbered_bids_route@12 main_accept_bid_route@13

main_after_if_else@16:
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    intc_0 // 0
    return

main_accept_bid_route@13:
    // smart_contracts/digital_marketplace/contract.py:205
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    intc_1 // 1
    txn OnCompletion
    shl
    pushint 3 // 3
    &
    assert // OnCompletion is not one of NoOp, OptIn
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/digital_marketplace/contract.py:205
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    callsub accept_bid
    intc_1 // 1
    return

main_claim_unencumbered_bids_route@12:
    // smart_contracts/digital_marketplace/contract.py:182
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    intc_1 // 1
    txn OnCompletion
    shl
    pushint 3 // 3
    &
    assert // OnCompletion is not one of NoOp, OptIn
    txn ApplicationID
    assert // can only call when not creating
    callsub claim_unencumbered_bids
    intc_1 // 1
    return

main_bid_route@11:
    // smart_contracts/digital_marketplace/contract.py:143
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/digital_marketplace/contract.py:143
    // @abimethod
    callsub bid
    intc_1 // 1
    return

main_buy_route@10:
    // smart_contracts/digital_marketplace/contract.py:128
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/digital_marketplace/contract.py:128
    // @abimethod
    callsub buy
    intc_1 // 1
    return

main_close_sale_route@9:
    // smart_contracts/digital_marketplace/contract.py:112
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    intc_1 // 1
    txn OnCompletion
    shl
    pushint 3 // 3
    &
    assert // OnCompletion is not one of NoOp, OptIn
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/digital_marketplace/contract.py:112
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    callsub close_sale
    intc_1 // 1
    return

main_open_sale_route@8:
    // smart_contracts/digital_marketplace/contract.py:92
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    // smart_contracts/digital_marketplace/contract.py:92
    // @abimethod
    callsub open_sale
    intc_1 // 1
    return

main_sponsor_asset_route@7:
    // smart_contracts/digital_marketplace/contract.py:78
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/digital_marketplace/contract.py:78
    // @abimethod
    callsub sponsor_asset
    intc_1 // 1
    return

main_withdraw_route@6:
    // smart_contracts/digital_marketplace/contract.py:69
    // @abimethod(allow_actions=["NoOp", "CloseOut"])
    intc_1 // 1
    txn OnCompletion
    shl
    pushint 5 // 5
    &
    assert // OnCompletion is not one of NoOp, CloseOut
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/digital_marketplace/contract.py:69
    // @abimethod(allow_actions=["NoOp", "CloseOut"])
    callsub withdraw
    intc_1 // 1
    return

main_deposit_route@5:
    // smart_contracts/digital_marketplace/contract.py:58
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    intc_1 // 1
    txn OnCompletion
    shl
    pushint 3 // 3
    &
    assert // OnCompletion is not one of NoOp, OptIn
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/digital_marketplace/contract.py:58
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    callsub deposit
    intc_1 // 1
    return

main_bare_routing@14:
    // smart_contracts/digital_marketplace/contract.py:51
    // class DigitalMarketplace(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@16
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.digital_marketplace.subroutines.sales_box_mbr(prefix_length: uint64) -> uint64:
sales_box_mbr:
    // smart_contracts/digital_marketplace/subroutines.py:6-7
    // @subroutine
    // def sales_box_mbr(prefix_length: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/digital_marketplace/subroutines.py:10-13
    // # Domain separator
    // prefix_length +
    // # SaleKey
    // 32 + 8 +
    frame_dig -1
    // smart_contracts/digital_marketplace/subroutines.py:12-13
    // # SaleKey
    // 32 + 8 +
    pushint 32 // 32
    // smart_contracts/digital_marketplace/subroutines.py:10-13
    // # Domain separator
    // prefix_length +
    // # SaleKey
    // 32 + 8 +
    +
    // smart_contracts/digital_marketplace/subroutines.py:12-13
    // # SaleKey
    // 32 + 8 +
    pushint 8 // 8
    // smart_contracts/digital_marketplace/subroutines.py:10-13
    // # Domain separator
    // prefix_length +
    // # SaleKey
    // 32 + 8 +
    +
    // smart_contracts/digital_marketplace/subroutines.py:14-17
    // # Sale
    // # Since the Sale type contains one dynamic type,
    // #  it's got a 2 byte prefix pointing to that dynamic type
    // 2 +
    pushint 2 // 2
    // smart_contracts/digital_marketplace/subroutines.py:10-17
    // # Domain separator
    // prefix_length +
    // # SaleKey
    // 32 + 8 +
    // # Sale
    // # Since the Sale type contains one dynamic type,
    // #  it's got a 2 byte prefix pointing to that dynamic type
    // 2 +
    +
    // smart_contracts/digital_marketplace/subroutines.py:18-19
    // # amount & cost fields
    // 8 + 8 +
    pushint 8 // 8
    // smart_contracts/digital_marketplace/subroutines.py:10-19
    // # Domain separator
    // prefix_length +
    // # SaleKey
    // 32 + 8 +
    // # Sale
    // # Since the Sale type contains one dynamic type,
    // #  it's got a 2 byte prefix pointing to that dynamic type
    // 2 +
    // # amount & cost fields
    // 8 + 8 +
    +
    // smart_contracts/digital_marketplace/subroutines.py:18-19
    // # amount & cost fields
    // 8 + 8 +
    pushint 8 // 8
    // smart_contracts/digital_marketplace/subroutines.py:10-19
    // # Domain separator
    // prefix_length +
    // # SaleKey
    // 32 + 8 +
    // # Sale
    // # Since the Sale type contains one dynamic type,
    // #  it's got a 2 byte prefix pointing to that dynamic type
    // 2 +
    // # amount & cost fields
    // 8 + 8 +
    +
    // smart_contracts/digital_marketplace/subroutines.py:20-21
    // # bid field is a dynamic array and so it has got a length prefix
    // 2 +
    pushint 2 // 2
    // smart_contracts/digital_marketplace/subroutines.py:10-21
    // # Domain separator
    // prefix_length +
    // # SaleKey
    // 32 + 8 +
    // # Sale
    // # Since the Sale type contains one dynamic type,
    // #  it's got a 2 byte prefix pointing to that dynamic type
    // 2 +
    // # amount & cost fields
    // 8 + 8 +
    // # bid field is a dynamic array and so it has got a length prefix
    // 2 +
    +
    // smart_contracts/digital_marketplace/subroutines.py:22-23
    // # One optional Bid type
    // (32 + 8)
    pushint 40 // 40
    // smart_contracts/digital_marketplace/subroutines.py:10-23
    // # Domain separator
    // prefix_length +
    // # SaleKey
    // 32 + 8 +
    // # Sale
    // # Since the Sale type contains one dynamic type,
    // #  it's got a 2 byte prefix pointing to that dynamic type
    // 2 +
    // # amount & cost fields
    // 8 + 8 +
    // # bid field is a dynamic array and so it has got a length prefix
    // 2 +
    // # One optional Bid type
    // (32 + 8)
    +
    // smart_contracts/digital_marketplace/subroutines.py:8-9
    // # fmt: off
    // return 2_500 + 400 * (
    pushint 400 // 400
    // smart_contracts/digital_marketplace/subroutines.py:8-24
    // # fmt: off
    // return 2_500 + 400 * (
    //     # Domain separator
    //     prefix_length +
    //     # SaleKey
    //     32 + 8 +
    //     # Sale
    //     # Since the Sale type contains one dynamic type,
    //     #  it's got a 2 byte prefix pointing to that dynamic type
    //     2 +
    //     # amount & cost fields
    //     8 + 8 +
    //     # bid field is a dynamic array and so it has got a length prefix
    //     2 +
    //     # One optional Bid type
    //     (32 + 8)
    // )
    *
    // smart_contracts/digital_marketplace/subroutines.py:8-9
    // # fmt: off
    // return 2_500 + 400 * (
    pushint 2500 // 2500
    // smart_contracts/digital_marketplace/subroutines.py:8-24
    // # fmt: off
    // return 2_500 + 400 * (
    //     # Domain separator
    //     prefix_length +
    //     # SaleKey
    //     32 + 8 +
    //     # Sale
    //     # Since the Sale type contains one dynamic type,
    //     #  it's got a 2 byte prefix pointing to that dynamic type
    //     2 +
    //     # amount & cost fields
    //     8 + 8 +
    //     # bid field is a dynamic array and so it has got a length prefix
    //     2 +
    //     # One optional Bid type
    //     (32 + 8)
    // )
    +
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.deposit(payment: uint64) -> void:
deposit:
    // smart_contracts/digital_marketplace/contract.py:58-59
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    // def deposit(self, payment: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:60
    // assert payment.sender == Txn.sender, err.DIFFERENT_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Different sender
    // smart_contracts/digital_marketplace/contract.py:62
    // payment.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/digital_marketplace/contract.py:61-63
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong receiver
    // smart_contracts/digital_marketplace/contract.py:66
    // self.deposited.get(Txn.sender, default=UInt64(0)) + payment.amount
    txn Sender
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    frame_dig -1
    gtxns Amount
    // smart_contracts/digital_marketplace/contract.py:65
    // self.deposited[Txn.sender] = (
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:66
    // self.deposited.get(Txn.sender, default=UInt64(0)) + payment.amount
    cover 2
    +
    // smart_contracts/digital_marketplace/contract.py:65
    // self.deposited[Txn.sender] = (
    bytec_0 // "deposited"
    // smart_contracts/digital_marketplace/contract.py:65-67
    // self.deposited[Txn.sender] = (
    //     self.deposited.get(Txn.sender, default=UInt64(0)) + payment.amount
    // )
    swap
    app_local_put
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.withdraw(amount: bytes) -> void:
withdraw:
    // smart_contracts/digital_marketplace/contract.py:69-70
    // @abimethod(allow_actions=["NoOp", "CloseOut"])
    // def withdraw(self, amount: arc4.UInt64) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:71
    // if Txn.on_completion == OnCompleteAction.CloseOut:
    txn OnCompletion
    pushint 2 // CloseOut
    ==
    bz withdraw_after_if_else@2
    // smart_contracts/digital_marketplace/contract.py:72
    // assert self.deposited[Txn.sender] == amount.native, err.BALANCE_NOT_EMPTY
    txn Sender
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    frame_dig -1
    btoi
    ==
    assert // Balance not empty

withdraw_after_if_else@2:
    // smart_contracts/digital_marketplace/contract.py:74
    // self.deposited[Txn.sender] -= amount.native
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    frame_dig -1
    btoi
    swap
    dig 1
    -
    uncover 2
    bytec_0 // "deposited"
    uncover 2
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:76
    // itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    itxn_begin
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.sponsor_asset(asset: uint64) -> void:
sponsor_asset:
    // smart_contracts/digital_marketplace/contract.py:78-79
    // @abimethod
    // def sponsor_asset(self, asset: Asset) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:80
    // assert not Global.current_application_address.is_opted_in(
    global CurrentApplicationAddress
    // smart_contracts/digital_marketplace/contract.py:80-82
    // assert not Global.current_application_address.is_opted_in(
    //     asset
    // ), err.ALREADY_OPTED_IN
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    !
    assert // Already opted in
    // smart_contracts/digital_marketplace/contract.py:84
    // self.deposited[Txn.sender] -= Global.asset_opt_in_min_balance
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    global AssetOptInMinBalance
    -
    bytec_0 // "deposited"
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:86-90
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:88
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/digital_marketplace/contract.py:89
    // asset_amount=0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:86
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:86-90
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.open_sale(asset_deposit: uint64, cost: bytes) -> void:
open_sale:
    // smart_contracts/digital_marketplace/contract.py:92-95
    // @abimethod
    // def open_sale(
    //     self, asset_deposit: gtxn.AssetTransferTransaction, cost: arc4.UInt64
    // ) -> None:
    proto 2 0
    // smart_contracts/digital_marketplace/contract.py:96
    // assert asset_deposit.sender == Txn.sender, err.DIFFERENT_SENDER
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert // Different sender
    // smart_contracts/digital_marketplace/contract.py:98
    // asset_deposit.asset_receiver == Global.current_application_address
    frame_dig -2
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/digital_marketplace/contract.py:97-99
    // assert (
    //     asset_deposit.asset_receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong receiver
    // smart_contracts/digital_marketplace/contract.py:102
    // arc4.Address(Txn.sender), arc4.UInt64(asset_deposit.xfer_asset.id)
    txn Sender
    frame_dig -2
    gtxns XferAsset
    itob
    // smart_contracts/digital_marketplace/contract.py:101-103
    // sale_key = SaleKey(
    //     arc4.Address(Txn.sender), arc4.UInt64(asset_deposit.xfer_asset.id)
    // )
    concat
    // smart_contracts/digital_marketplace/contract.py:104
    // assert not self.sales.maybe(sale_key)[1], err.SALE_ALREADY_EXISTS
    bytec_2 // "sales"
    swap
    concat
    dup
    box_get
    bury 1
    !
    assert // Sale already exists
    // smart_contracts/digital_marketplace/contract.py:106
    // self.deposited[Txn.sender] -= sales_box_mbr(self.sales.key_prefix.length)
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    pushint 5 // 5
    callsub sales_box_mbr
    -
    bytec_0 // "deposited"
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:109
    // arc4.UInt64(asset_deposit.asset_amount), cost, arc4.DynamicArray[Bid]()
    frame_dig -2
    gtxns AssetAmount
    itob
    // smart_contracts/digital_marketplace/contract.py:108-110
    // self.sales[sale_key] = Sale(
    //     arc4.UInt64(asset_deposit.asset_amount), cost, arc4.DynamicArray[Bid]()
    // )
    frame_dig -1
    concat
    pushbytes 0x0012
    concat
    // smart_contracts/digital_marketplace/contract.py:109
    // arc4.UInt64(asset_deposit.asset_amount), cost, arc4.DynamicArray[Bid]()
    bytec_3 // 0x0000
    // smart_contracts/digital_marketplace/contract.py:108-110
    // self.sales[sale_key] = Sale(
    //     arc4.UInt64(asset_deposit.asset_amount), cost, arc4.DynamicArray[Bid]()
    // )
    concat
    dig 1
    box_del
    pop
    box_put
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.close_sale(asset: uint64) -> void:
close_sale:
    // smart_contracts/digital_marketplace/contract.py:112-113
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    // def close_sale(self, asset: Asset) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:114
    // sale_key = SaleKey(arc4.Address(Txn.sender), arc4.UInt64(asset.id))
    txn Sender
    frame_dig -1
    itob
    concat
    // smart_contracts/digital_marketplace/contract.py:116-120
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Txn.sender,
    //     asset_amount=self.sales[sale_key].amount.native,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:118
    // asset_receiver=Txn.sender,
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:119
    // asset_amount=self.sales[sale_key].amount.native,
    bytec_2 // "sales"
    uncover 2
    concat
    dup
    box_get
    assert // check self.sales entry exists
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    swap
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:116
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:116-120
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=Txn.sender,
    //     asset_amount=self.sales[sale_key].amount.native,
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:123
    // Txn.sender, default=UInt64(0)
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:122-124
    // self.deposited[Txn.sender] = self.deposited.get(
    //     Txn.sender, default=UInt64(0)
    // ) + sales_box_mbr(self.sales.key_prefix.length)
    intc_0 // 0
    // smart_contracts/digital_marketplace/contract.py:122
    // self.deposited[Txn.sender] = self.deposited.get(
    bytec_0 // "deposited"
    // smart_contracts/digital_marketplace/contract.py:122-124
    // self.deposited[Txn.sender] = self.deposited.get(
    //     Txn.sender, default=UInt64(0)
    // ) + sales_box_mbr(self.sales.key_prefix.length)
    app_local_get_ex
    // smart_contracts/digital_marketplace/contract.py:123
    // Txn.sender, default=UInt64(0)
    intc_0 // 0
    // smart_contracts/digital_marketplace/contract.py:122-124
    // self.deposited[Txn.sender] = self.deposited.get(
    //     Txn.sender, default=UInt64(0)
    // ) + sales_box_mbr(self.sales.key_prefix.length)
    cover 2
    select
    // smart_contracts/digital_marketplace/contract.py:124
    // ) + sales_box_mbr(self.sales.key_prefix.length)
    pushint 5 // 5
    callsub sales_box_mbr
    // smart_contracts/digital_marketplace/contract.py:122
    // self.deposited[Txn.sender] = self.deposited.get(
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:122-124
    // self.deposited[Txn.sender] = self.deposited.get(
    //     Txn.sender, default=UInt64(0)
    // ) + sales_box_mbr(self.sales.key_prefix.length)
    cover 2
    +
    // smart_contracts/digital_marketplace/contract.py:122
    // self.deposited[Txn.sender] = self.deposited.get(
    bytec_0 // "deposited"
    // smart_contracts/digital_marketplace/contract.py:122-124
    // self.deposited[Txn.sender] = self.deposited.get(
    //     Txn.sender, default=UInt64(0)
    // ) + sales_box_mbr(self.sales.key_prefix.length)
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:126
    // del self.sales[sale_key]
    box_del
    pop
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.buy(sale_key: bytes) -> void:
buy:
    // smart_contracts/digital_marketplace/contract.py:128-129
    // @abimethod
    // def buy(self, sale_key: SaleKey) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:130
    // self.deposited[Txn.sender] -= self.sales[sale_key].cost.native
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    bytec_2 // "sales"
    frame_dig -1
    concat
    dup
    box_get
    assert // check self.sales entry exists
    pushint 8 // 8
    extract_uint64
    uncover 2
    swap
    -
    uncover 2
    bytec_0 // "deposited"
    uncover 2
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:131
    // self.deposited[sale_key.owner.native] += self.sales[
    frame_dig -1
    extract 0 32 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    // smart_contracts/digital_marketplace/contract.py:131-133
    // self.deposited[sale_key.owner.native] += self.sales[
    //     sale_key
    // ].cost.native + sales_box_mbr(self.sales.key_prefix.length)
    dig 2
    box_get
    assert // check self.sales entry exists
    pushint 8 // 8
    extract_uint64
    // smart_contracts/digital_marketplace/contract.py:133
    // ].cost.native + sales_box_mbr(self.sales.key_prefix.length)
    pushint 5 // 5
    callsub sales_box_mbr
    // smart_contracts/digital_marketplace/contract.py:131-133
    // self.deposited[sale_key.owner.native] += self.sales[
    //     sale_key
    // ].cost.native + sales_box_mbr(self.sales.key_prefix.length)
    +
    +
    // smart_contracts/digital_marketplace/contract.py:131
    // self.deposited[sale_key.owner.native] += self.sales[
    bytec_0 // "deposited"
    // smart_contracts/digital_marketplace/contract.py:131-133
    // self.deposited[sale_key.owner.native] += self.sales[
    //     sale_key
    // ].cost.native + sales_box_mbr(self.sales.key_prefix.length)
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:135-139
    // itxn.AssetTransfer(
    //     xfer_asset=sale_key.asset.native,
    //     asset_receiver=Txn.sender,
    //     asset_amount=self.sales[sale_key].amount.native,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:136
    // xfer_asset=sale_key.asset.native,
    frame_dig -1
    pushint 32 // 32
    extract_uint64
    // smart_contracts/digital_marketplace/contract.py:137
    // asset_receiver=Txn.sender,
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:138
    // asset_amount=self.sales[sale_key].amount.native,
    dig 2
    box_get
    assert // check self.sales entry exists
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:135
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:135-139
    // itxn.AssetTransfer(
    //     xfer_asset=sale_key.asset.native,
    //     asset_receiver=Txn.sender,
    //     asset_amount=self.sales[sale_key].amount.native,
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:141
    // del self.sales[sale_key]
    box_del
    pop
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.bid(sale_key: bytes, new_bid_amount: bytes) -> void:
bid:
    // smart_contracts/digital_marketplace/contract.py:143-144
    // @abimethod
    // def bid(self, sale_key: SaleKey, new_bid_amount: arc4.UInt64) -> None:
    proto 2 0
    intc_0 // 0
    pushbytes ""
    dupn 2
    // smart_contracts/digital_marketplace/contract.py:145
    // maybe_best_bid = self.sales[sale_key].bid.copy()
    bytec_2 // "sales"
    frame_dig -2
    concat
    dup
    box_get
    assert // check self.sales entry exists
    dup
    intc_3 // 16
    extract_uint16
    dig 1
    len
    substring3
    dup
    cover 2
    // smart_contracts/digital_marketplace/contract.py:146
    // if maybe_best_bid:
    bytec_3 // 0x0000
    !=
    bz bid_else_body@2
    // smart_contracts/digital_marketplace/contract.py:148
    // maybe_best_bid[0].amount.native < new_bid_amount.native
    frame_dig 4
    extract 2 40
    pushint 32 // 32
    extract_uint64
    frame_dig -1
    btoi
    <
    // smart_contracts/digital_marketplace/contract.py:147-149
    // assert (
    //     maybe_best_bid[0].amount.native < new_bid_amount.native
    // ), err.WORSE_BID
    assert // Worse bid
    // smart_contracts/digital_marketplace/contract.py:152
    // bidder=arc4.Address(Txn.sender), amount=new_bid_amount
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:151-153
    // self.sales[sale_key].bid[0] = Bid(
    //     bidder=arc4.Address(Txn.sender), amount=new_bid_amount
    // )
    frame_dig -1
    concat
    // smart_contracts/digital_marketplace/contract.py:151
    // self.sales[sale_key].bid[0] = Bid(
    dig 1
    box_get
    assert // check self.sales entry exists
    dup
    intc_3 // 16
    extract_uint16
    dig 1
    len
    dig 2
    dig 2
    uncover 2
    substring3
    // smart_contracts/digital_marketplace/contract.py:151-153
    // self.sales[sale_key].bid[0] = Bid(
    //     bidder=arc4.Address(Txn.sender), amount=new_bid_amount
    // )
    dup
    intc_0 // 0
    extract_uint16
    assert // Index access is out of bounds
    uncover 3
    replace2 2
    uncover 2
    intc_0 // 0
    uncover 3
    extract3
    swap
    concat
    dig 1
    box_del
    pop
    box_put

bid_after_if_else@3:
    // smart_contracts/digital_marketplace/contract.py:159
    // self.deposited[Txn.sender] -= new_bid_amount.native
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    frame_dig -1
    btoi
    -
    bytec_0 // "deposited"
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:161
    // if self.placed_bids.maybe(arc4.Address(Txn.sender))[1]:
    bytec_1 // "placed_bids"
    txn Sender
    concat
    box_get
    bury 1
    bz bid_else_body@8
    // smart_contracts/digital_marketplace/contract.py:163
    // self.placed_bids[arc4.Address(Txn.sender)].copy(), sale_key.copy()
    bytec_1 // "placed_bids"
    txn Sender
    concat
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.placed_bids entry exists
    // smart_contracts/digital_marketplace/subroutines.py:45
    // for i in urange(placed_bids.length):
    intc_0 // 0
    extract_uint16
    frame_bury 3
    intc_0 // 0
    frame_bury 1

bid_for_header@13:
    // smart_contracts/digital_marketplace/subroutines.py:45
    // for i in urange(placed_bids.length):
    frame_dig 1
    frame_dig 3
    <
    bz bid_after_for@17
    // smart_contracts/digital_marketplace/subroutines.py:46
    // if placed_bids[i].sale_key == key:
    frame_dig 0
    extract 2 0
    frame_dig 1
    intc_2 // 48
    *
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    extract 0 40 // on error: Index access is out of bounds
    frame_dig -2
    ==
    bz bid_after_if_else@16
    // smart_contracts/digital_marketplace/subroutines.py:47
    // return True, i
    intc_1 // 1
    frame_dig 1
    frame_bury 2

bid_after_inlined_smart_contracts.digital_marketplace.subroutines.find_placed_bid@18:
    // smart_contracts/digital_marketplace/contract.py:165
    // if found:
    bz bid_else_body@6
    // smart_contracts/digital_marketplace/contract.py:166
    // self.deposited[Txn.sender] += self.placed_bids[
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    bytec_1 // "placed_bids"
    // smart_contracts/digital_marketplace/contract.py:167
    // arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:166-168
    // self.deposited[Txn.sender] += self.placed_bids[
    //     arc4.Address(Txn.sender)
    // ][index].bid_amount.native
    concat
    box_get
    assert // check self.placed_bids entry exists
    extract 2 0
    frame_dig 2
    dup
    cover 4
    intc_2 // 48
    *
    swap
    dig 1
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    pushint 40 // 40
    extract_uint64
    uncover 2
    +
    uncover 2
    // smart_contracts/digital_marketplace/contract.py:166
    // self.deposited[Txn.sender] += self.placed_bids[
    bytec_0 // "deposited"
    // smart_contracts/digital_marketplace/contract.py:166-168
    // self.deposited[Txn.sender] += self.placed_bids[
    //     arc4.Address(Txn.sender)
    // ][index].bid_amount.native
    uncover 2
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:169-171
    // self.placed_bids[arc4.Address(Txn.sender)][index] = PlacedBid(
    //     sale_key.copy(), new_bid_amount
    // )
    frame_dig -2
    frame_dig -1
    concat
    // smart_contracts/digital_marketplace/contract.py:169
    // self.placed_bids[arc4.Address(Txn.sender)][index] = PlacedBid(
    bytec_1 // "placed_bids"
    txn Sender
    concat
    dup
    box_get
    assert // check self.placed_bids entry exists
    // smart_contracts/digital_marketplace/contract.py:169-171
    // self.placed_bids[arc4.Address(Txn.sender)][index] = PlacedBid(
    //     sale_key.copy(), new_bid_amount
    // )
    dup
    intc_0 // 0
    extract_uint16
    uncover 5
    >
    assert // Index access is out of bounds
    uncover 3
    pushint 2 // 2
    +
    uncover 3
    replace3
    dig 1
    box_del
    pop
    box_put
    retsub

bid_else_body@6:
    // smart_contracts/digital_marketplace/contract.py:173
    // self.placed_bids[arc4.Address(Txn.sender)].append(
    bytec_1 // "placed_bids"
    txn Sender
    concat
    dup
    box_get
    assert // check self.placed_bids entry exists
    // smart_contracts/digital_marketplace/contract.py:173-175
    // self.placed_bids[arc4.Address(Txn.sender)].append(
    //     PlacedBid(sale_key.copy(), new_bid_amount)
    // )
    extract 2 0
    // smart_contracts/digital_marketplace/contract.py:174
    // PlacedBid(sale_key.copy(), new_bid_amount)
    frame_dig -2
    frame_dig -1
    concat
    // smart_contracts/digital_marketplace/contract.py:173-175
    // self.placed_bids[arc4.Address(Txn.sender)].append(
    //     PlacedBid(sale_key.copy(), new_bid_amount)
    // )
    concat
    dup
    len
    intc_2 // 48
    /
    itob
    extract 6 2
    swap
    concat
    dig 1
    box_del
    pop
    box_put
    retsub

bid_after_if_else@16:
    // smart_contracts/digital_marketplace/subroutines.py:45
    // for i in urange(placed_bids.length):
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b bid_for_header@13

bid_after_for@17:
    // smart_contracts/digital_marketplace/subroutines.py:48
    // return False, UInt64(0)
    intc_0 // 0
    dup
    frame_bury 2
    // smart_contracts/digital_marketplace/contract.py:162-164
    // found, index = find_placed_bid(
    //     self.placed_bids[arc4.Address(Txn.sender)].copy(), sale_key.copy()
    // )
    b bid_after_inlined_smart_contracts.digital_marketplace.subroutines.find_placed_bid@18

bid_else_body@8:
    // smart_contracts/digital_marketplace/contract.py:177
    // self.deposited[Txn.sender] -= placed_bids_box_mbr()
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    // smart_contracts/digital_marketplace/subroutines.py:30-38
    // return UInt64(
    //     2_500
    //     + 400
    //     * (
    //         # assuming it's possible to fill an entire box
    //         64
    //         + 32768
    //     )
    // )
    intc 4 // 13135300
    // smart_contracts/digital_marketplace/contract.py:177
    // self.deposited[Txn.sender] -= placed_bids_box_mbr()
    -
    bytec_0 // "deposited"
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:179
    // PlacedBid(sale_key.copy(), new_bid_amount)
    frame_dig -2
    frame_dig -1
    concat
    // smart_contracts/digital_marketplace/contract.py:178-180
    // self.placed_bids[arc4.Address(Txn.sender)] = arc4.DynamicArray[PlacedBid](
    //     PlacedBid(sale_key.copy(), new_bid_amount)
    // )
    pushbytes 0x0001
    swap
    concat
    // smart_contracts/digital_marketplace/contract.py:178
    // self.placed_bids[arc4.Address(Txn.sender)] = arc4.DynamicArray[PlacedBid](
    bytec_1 // "placed_bids"
    txn Sender
    concat
    // smart_contracts/digital_marketplace/contract.py:178-180
    // self.placed_bids[arc4.Address(Txn.sender)] = arc4.DynamicArray[PlacedBid](
    //     PlacedBid(sale_key.copy(), new_bid_amount)
    // )
    dup
    box_del
    pop
    swap
    box_put
    retsub

bid_else_body@2:
    // smart_contracts/digital_marketplace/contract.py:155
    // self.sales[sale_key].bid.append(
    dup
    box_get
    assert // check self.sales entry exists
    dup
    intc_3 // 16
    extract_uint16
    dig 1
    len
    dig 2
    dig 2
    uncover 2
    substring3
    // smart_contracts/digital_marketplace/contract.py:155-157
    // self.sales[sale_key].bid.append(
    //     Bid(bidder=arc4.Address(Txn.sender), amount=new_bid_amount)
    // )
    extract 2 0
    // smart_contracts/digital_marketplace/contract.py:156
    // Bid(bidder=arc4.Address(Txn.sender), amount=new_bid_amount)
    txn Sender
    frame_dig -1
    concat
    // smart_contracts/digital_marketplace/contract.py:155-157
    // self.sales[sale_key].bid.append(
    //     Bid(bidder=arc4.Address(Txn.sender), amount=new_bid_amount)
    // )
    concat
    dup
    len
    pushint 40 // 40
    /
    itob
    extract 6 2
    swap
    concat
    uncover 2
    intc_0 // 0
    uncover 3
    extract3
    swap
    concat
    dig 1
    box_del
    pop
    box_put
    b bid_after_if_else@3


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.claim_unencumbered_bids() -> void:
claim_unencumbered_bids:
    // smart_contracts/digital_marketplace/contract.py:182-183
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    // def claim_unencumbered_bids(self) -> None:
    proto 0 0
    intc_0 // 0
    dup
    // smart_contracts/digital_marketplace/contract.py:184
    // placed_bids = self.placed_bids[arc4.Address(Txn.sender)].copy()
    bytec_1 // "placed_bids"
    txn Sender
    concat
    box_get
    swap
    dup
    uncover 2
    assert // check self.placed_bids entry exists
    // smart_contracts/digital_marketplace/contract.py:185
    // self.placed_bids[arc4.Address(Txn.sender)] = arc4.DynamicArray[PlacedBid]()
    bytec_1 // "placed_bids"
    txn Sender
    concat
    dup
    box_del
    pop
    bytec_3 // 0x0000
    box_put
    // smart_contracts/digital_marketplace/contract.py:187
    // for i in urange(placed_bids.length):
    intc_0 // 0
    extract_uint16
    intc_0 // 0

claim_unencumbered_bids_for_header@1:
    // smart_contracts/digital_marketplace/contract.py:187
    // for i in urange(placed_bids.length):
    frame_dig 4
    frame_dig 3
    <
    bz claim_unencumbered_bids_after_for@9
    // smart_contracts/digital_marketplace/contract.py:189
    // not self.sales.maybe(placed_bids[i].sale_key)[1]
    frame_dig 2
    extract 2 0
    frame_dig 4
    intc_2 // 48
    *
    intc_2 // 48
    extract3 // on error: Index access is out of bounds
    dup
    frame_bury 0
    extract 0 40 // on error: Index access is out of bounds
    bytec_2 // "sales"
    swap
    concat
    dup
    frame_bury 1
    box_get
    bury 1
    bz claim_unencumbered_bids_if_body@5
    // smart_contracts/digital_marketplace/contract.py:190
    // or not self.sales.maybe(placed_bids[i].sale_key)[0].bid
    frame_dig 1
    box_get
    pop
    dup
    intc_3 // 16
    extract_uint16
    dig 1
    len
    substring3
    bytec_3 // 0x0000
    ==
    // smart_contracts/digital_marketplace/contract.py:189-192
    // not self.sales.maybe(placed_bids[i].sale_key)[1]
    // or not self.sales.maybe(placed_bids[i].sale_key)[0].bid
    // or not self.sales.maybe(placed_bids[i].sale_key)[0].bid[0].bidder.native
    // == Txn.sender
    bnz claim_unencumbered_bids_if_body@5
    // smart_contracts/digital_marketplace/contract.py:191
    // or not self.sales.maybe(placed_bids[i].sale_key)[0].bid[0].bidder.native
    frame_dig 1
    box_get
    pop
    dup
    intc_3 // 16
    extract_uint16
    dig 1
    len
    substring3
    extract 2 40
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/digital_marketplace/contract.py:192
    // == Txn.sender
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:191-192
    // or not self.sales.maybe(placed_bids[i].sale_key)[0].bid[0].bidder.native
    // == Txn.sender
    ==
    bnz claim_unencumbered_bids_else_body@6

claim_unencumbered_bids_if_body@5:
    // smart_contracts/digital_marketplace/contract.py:195
    // self.deposited.get(Txn.sender, UInt64(0))
    txn Sender
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/digital_marketplace/contract.py:196
    // + placed_bids[i].bid_amount.native
    frame_dig 0
    pushint 40 // 40
    extract_uint64
    // smart_contracts/digital_marketplace/contract.py:194
    // self.deposited[Txn.sender] = (
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:195-196
    // self.deposited.get(Txn.sender, UInt64(0))
    // + placed_bids[i].bid_amount.native
    cover 2
    +
    // smart_contracts/digital_marketplace/contract.py:194
    // self.deposited[Txn.sender] = (
    bytec_0 // "deposited"
    // smart_contracts/digital_marketplace/contract.py:194-197
    // self.deposited[Txn.sender] = (
    //     self.deposited.get(Txn.sender, UInt64(0))
    //     + placed_bids[i].bid_amount.native
    // )
    swap
    app_local_put

claim_unencumbered_bids_after_if_else@7:
    // smart_contracts/digital_marketplace/contract.py:187
    // for i in urange(placed_bids.length):
    frame_dig 4
    intc_1 // 1
    +
    frame_bury 4
    b claim_unencumbered_bids_for_header@1

claim_unencumbered_bids_else_body@6:
    // smart_contracts/digital_marketplace/contract.py:199
    // self.placed_bids[arc4.Address(Txn.sender)].append(placed_bids[i].copy())
    bytec_1 // "placed_bids"
    txn Sender
    concat
    dup
    box_get
    assert // check self.placed_bids entry exists
    extract 2 0
    frame_dig 0
    concat
    dup
    len
    intc_2 // 48
    /
    itob
    extract 6 2
    swap
    concat
    dig 1
    box_del
    pop
    box_put
    b claim_unencumbered_bids_after_if_else@7

claim_unencumbered_bids_after_for@9:
    // smart_contracts/digital_marketplace/contract.py:201
    // if not self.placed_bids[arc4.Address(Txn.sender)]:
    bytec_1 // "placed_bids"
    txn Sender
    concat
    box_get
    assert // check self.placed_bids entry exists
    bytec_3 // 0x0000
    ==
    bz claim_unencumbered_bids_after_if_else@11
    // smart_contracts/digital_marketplace/contract.py:202
    // self.deposited[Txn.sender] += placed_bids_box_mbr()
    txn Sender
    dup
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    assert // check self.deposited exists for account
    // smart_contracts/digital_marketplace/subroutines.py:30-38
    // return UInt64(
    //     2_500
    //     + 400
    //     * (
    //         # assuming it's possible to fill an entire box
    //         64
    //         + 32768
    //     )
    // )
    intc 4 // 13135300
    // smart_contracts/digital_marketplace/contract.py:202
    // self.deposited[Txn.sender] += placed_bids_box_mbr()
    +
    bytec_0 // "deposited"
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:203
    // del self.placed_bids[arc4.Address(Txn.sender)]
    bytec_1 // "placed_bids"
    txn Sender
    concat
    box_del
    pop

claim_unencumbered_bids_after_if_else@11:
    retsub


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.accept_bid(asset: bytes) -> void:
accept_bid:
    // smart_contracts/digital_marketplace/contract.py:205-206
    // @abimethod(allow_actions=["NoOp", "OptIn"])
    // def accept_bid(self, asset: arc4.UInt64) -> None:
    proto 1 0
    // smart_contracts/digital_marketplace/contract.py:207
    // sale_key = SaleKey(owner=arc4.Address(Txn.sender), asset=asset)
    txn Sender
    frame_dig -1
    concat
    // smart_contracts/digital_marketplace/contract.py:208
    // sale = self.sales[sale_key].copy()
    bytec_2 // "sales"
    swap
    concat
    dup
    box_get
    assert // check self.sales entry exists
    // smart_contracts/digital_marketplace/contract.py:209
    // current_best_bid = sale.bid[0].copy()
    dup
    intc_3 // 16
    extract_uint16
    dig 1
    len
    dig 2
    cover 2
    substring3
    extract 2 40
    // smart_contracts/digital_marketplace/contract.py:212
    // self.deposited.get(Txn.sender, default=UInt64(0))
    txn Sender
    intc_0 // 0
    bytec_0 // "deposited"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/digital_marketplace/contract.py:213
    // + current_best_bid.amount.native
    dig 1
    pushint 32 // 32
    extract_uint64
    // smart_contracts/digital_marketplace/contract.py:212-213
    // self.deposited.get(Txn.sender, default=UInt64(0))
    // + current_best_bid.amount.native
    +
    // smart_contracts/digital_marketplace/contract.py:214
    // + sales_box_mbr(self.sales.key_prefix.length)
    pushint 5 // 5
    callsub sales_box_mbr
    // smart_contracts/digital_marketplace/contract.py:211
    // self.deposited[Txn.sender] = (
    txn Sender
    // smart_contracts/digital_marketplace/contract.py:212-214
    // self.deposited.get(Txn.sender, default=UInt64(0))
    // + current_best_bid.amount.native
    // + sales_box_mbr(self.sales.key_prefix.length)
    cover 2
    +
    // smart_contracts/digital_marketplace/contract.py:211
    // self.deposited[Txn.sender] = (
    bytec_0 // "deposited"
    // smart_contracts/digital_marketplace/contract.py:211-215
    // self.deposited[Txn.sender] = (
    //     self.deposited.get(Txn.sender, default=UInt64(0))
    //     + current_best_bid.amount.native
    //     + sales_box_mbr(self.sales.key_prefix.length)
    // )
    swap
    app_local_put
    // smart_contracts/digital_marketplace/contract.py:216-220
    // itxn.AssetTransfer(
    //     xfer_asset=asset.native,
    //     asset_receiver=current_best_bid.bidder.native,
    //     asset_amount=sale.amount.native,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:217
    // xfer_asset=asset.native,
    frame_dig -1
    btoi
    // smart_contracts/digital_marketplace/contract.py:218
    // asset_receiver=current_best_bid.bidder.native,
    swap
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/digital_marketplace/contract.py:219
    // asset_amount=sale.amount.native,
    uncover 2
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:216
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:216-220
    // itxn.AssetTransfer(
    //     xfer_asset=asset.native,
    //     asset_receiver=current_best_bid.bidder.native,
    //     asset_amount=sale.amount.native,
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:222
    // del self.sales[sale_key]
    box_del
    pop
    retsub
